
===== BLOCK 0 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_0
VAR_INPUT
    Axis_num : USINT;
    Execute : BOOL;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Axis_numOut : USINT;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_state : USINT;
    execute_before : BOOL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF NOT Execute AND stage &lt;&gt; 3(* FBS_InBuffer *) AND stage &lt;&gt; 4(* FBS_Moving *) THEN
    Done := FALSE;
    Active := FALSE;
    Busy := FALSE;
    CommandAborted := FALSE;
    stage := 0(* FBS_WaitExec *);
    execute_before := FALSE;
END_IF;
Axis_state := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 56) ;
IF (Axis_state = 0(* AS_Disabled *) OR Axis_state = 1(* AS_Errorstop *)) AND stage = 4(* FBS_Moving *) THEN
    CommandAborted := TRUE;
    stage := 0(* FBS_WaitExec *);
END_IF;
END_PROGRAM

===== BLOCK 1 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_1
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    BufferMode : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_busy : USINT;
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_relative_postion : REAL;
    Axis_run_next : USINT;
    acc : REAL;
    dec : REAL;
    execute_before : BOOL;
    jerk : REAL;
    pos : REAL;
    stage : USINT;
    vel : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        Axis_relative_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 96) ;
        vel := Velocity / 1000.0;
        acc := Acceleration / 1000000.0;
        dec := Deceleration / 1000000.0;
        jerk := Jerk / 1000000000.0;
        pos := Position - Axis_relative_postion;
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
        stage := 3(* FBS_CalcRoute *);
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            Axis_run_next := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 148);
            IF (BufferMode = 1 AND Axis_run_next &lt;&gt; 1) OR BufferMode &lt;&gt; 1 THEN
                stage := 2(* FBS_InBuffer *);
            END_IF;
        END_IF;
    END_IF;
END_IF;
IF stage = 2(* FBS_InBuffer *) THEN
    Axis_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 153);
    IF Axis_busy = 0 THEN
        stage := 3(* FBS_CalcRoute *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 2 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_2
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    pos : REAL;
    run_numberF : USINT;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    Axis_run_number := Axis_run_number MOD 255 + 1; // [1,255]
    run_numberF := Axis_run_number;
    start_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 176);
    IF pos &gt;= start_postion THEN
        direction := 1;
        s_all := pos - start_postion;
    ELSE
        direction := -1;
        s_all := start_postion - pos;
    END_IF;
    vs := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
    IF vs &lt;= -0.004(* MINV *) THEN
        vs := -1.0 * vs;
        now_direction := -1;
    ELSIF vs &gt;= 0.004(* MINV *) THEN
        now_direction := 1;
    ELSE
        vs := 0;
        now_direction := direction;
    END_IF;
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
    IF s_all &lt;= 0.001(* MINP *) THEN
        Done := TRUE;
        CommandAborted := FALSE;
        Busy := FALSE;
        Active := FALSE;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 3 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_3
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    run_mode : USINT;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        t1 := 0; t2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                vs := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 4 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_4
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk_mode : BOOL;
    now_direction : INT;
    run_mode : USINT;
    run_numberF : USINT;
    stage : USINT;
    t_all : REAL;
    t_now : UDINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
        CommandAborted := TRUE;
        Busy := FALSE;
        Active := FALSE;
        Done := FALSE;
    ELSE
        Busy := TRUE;
        Active := TRUE;
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 5 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_5
VAR_INPUT
    Axis_num : USINT;
    Execute : BOOL;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Axis_numOut : USINT;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_state : USINT;
    execute_before : BOOL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF NOT Execute AND stage &lt;&gt; 3(* FBS_InBuffer *) AND stage &lt;&gt; 4(* FBS_Moving *) THEN
    Error := FALSE;
    ErrorID := 0(* ER_NoError *);
    stage := 0(* FBS_WaitExec *);
    execute_before := FALSE;
END_IF;
Axis_state := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 56) ;
IF (Axis_state = 0(* AS_Disabled *) OR Axis_state = 1(* AS_Errorstop *)) AND stage = 4(* FBS_Moving *) THEN
    Error := TRUE;
    ErrorID := 16#01(* ER_StateError *);
    stage := 0(* FBS_WaitExec *);
END_IF;
END_PROGRAM

===== BLOCK 6 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_6
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_state : USINT;
    execute_before : BOOL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
        Error := TRUE;
        ErrorID := 16#02(* ER_ParameterError *);
    ELSIF Axis_state = 0(* MC_Disabled *) OR Axis_state = 1(* MC_Errorstop *) OR Axis_state = 4(* MC_Stopping *) THEN
        Error := TRUE;
        ErrorID := 16#01(* ER_StateError *);
    ELSE
        Error := FALSE;
        ErrorID := 16#00(* ER_NoError *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 7 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_7
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    pos : REAL;
    run_numberF : USINT;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    Axis_run_number := Axis_run_number MOD 255 + 1; // [1,255]
    run_numberF := Axis_run_number;
    start_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 176);
    IF pos &gt;= start_postion THEN
        direction := 1;
        s_all := pos - start_postion;
    ELSE
        direction := -1;
        s_all := start_postion - pos;
    END_IF;
    vs := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
    IF vs &lt;= -0.004(* MINV *) THEN
        vs := -1.0 * vs;
        now_direction := -1;
    ELSIF vs &gt;= 0.004(* MINV *) THEN
        now_direction := 1;
    ELSE
        vs := 0;
        now_direction := direction;
    END_IF;
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 8 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_8
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    run_mode : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                rvs := vs;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        vmax := vs;
                        t1 := 0; t2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                rvs := vs;
                vs := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
END_IF;
END_PROGRAM

===== BLOCK 9 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_9
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk_mode : BOOL;
    now_direction : INT;
    rt1 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    stage : USINT;
    t_all : REAL;
    t_now : UDINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    t_now := 0;
                END_IF;
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 10 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_10
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    stage : USINT;
    t_all : REAL;
    t_now : UDINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    t_now := 0;
                ELSIF t_now &lt;= rt1 THEN
                    now_stage_vs := rvs;
                ELSIF t_now &lt;= rt1 + rt2 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2;
                ELSIF t_now &lt; rt1 + rt2 + rt3 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2 - jerk * rt1 * rt2;
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 11 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_11
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                    ELSIF t_now &lt;= t1 THEN
                        now_stage_vs := vs;
                    ELSIF t_now &lt;= t1 + t2 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2;
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2;
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2 + jerk * t1 * t2;
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2 - jerk * t1 * t2;
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 THEN
                        now_stage_vs := vmax;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                        now_stage_vs := vmax;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 + t7 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2 - jerk * t5 * t6;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 12 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_12
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    blend_equal_vel : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    direction : INT;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    stage : USINT;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 13 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_13
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_now_velocity : REAL;
    Axis_run_number : USINT;
    blend_equal_vel : REAL;
    blend_start_a : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    run_mode : USINT;
    run_numberF : USINT;
    s_blend : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
            IF Axis_buffered_without_blending = 0 THEN
                IF (NOT jerk_mode AND t_now &gt; t1 AND t_now &lt; t_all) OR
                   (jerk_mode AND t_now &gt; t1 + t2 + t3 AND t_now &lt; t_all) THEN
                    IF jerk_mode THEN    // S型混成
                        IF t_now &lt;= t1 + t2 + t3 + t4 THEN
                            blend_start_a := 0;
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                            blend_start_a := jerk * (t_now - t1 - t2 - t3 - t4);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                            blend_start_a := jerk * t5;
                        ELSE
                            blend_start_a := jerk * (t5 - (t_now - t1 - t2 - t3 - t4 - t5 - t6)); // 跟c代码不同，多t6
                        END_IF;
                        IF blend_start_a &lt;&gt; 0 THEN
                            t5 := blend_start_a / jerk;
                        ELSE
                            t5 := 0;
                        END_IF;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        Axis_now_velocity := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
                        blend_start_v := RealAbs(Axis_now_velocity);
                        blend_equal_vel := blend_start_v - blend_start_a * t5 + jerk * t5 * t5 / 2;
                        IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                            run_mode := 4(* RM_BLENDING_EQU_ACC *);
                        ELSE                                                       // 混承速度 &lt;= 当前速度
                            run_mode := 3(* RM_BLENDING_EQU_DEC *);
                        END_IF;
                    ELSE                 // 梯形混成
                        IF t_now &lt; t1 + t2 THEN
                            blend_equal_vel := vmax;
                        ELSE
                            blend_equal_vel := vmax - dec * (UDINT_TO_REAL(t_now) - t1 - t2);
                        END_IF;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                            run_mode := 4(* RM_BLENDING_EQU_ACC *);
                        ELSE                                                       // 混承速度 &lt;= 当前速度
                            run_mode := 3(* RM_BLENDING_EQU_DEC *);
                        END_IF;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 14 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_14
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    BufferMode : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_busy : USINT;
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_run_next : USINT;
    execute_before : BOOL;
    jerk : REAL;
    jerk_mode : BOOL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        jerk := Jerk / 1000000000.0;
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
        stage := 3(* FBS_CalcRoute *);
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            Axis_run_next := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 148);
            IF (BufferMode = 1 AND Axis_run_next &lt;&gt; 1) OR BufferMode &lt;&gt; 1 THEN
                stage := 2(* FBS_InBuffer *);
            END_IF;
        END_IF;
    END_IF;
END_IF;
IF stage = 2(* FBS_InBuffer *) THEN
    Axis_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 153);
    IF Axis_busy = 0 THEN
        stage := 3(* FBS_CalcRoute *);
    END_IF;
END_IF;
IF stage = 3(* FBS_CalcRoute *) THEN
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 15 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_15
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    run_mode : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                rvs := vs;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        vmax := vs;
                        t1 := 0; t2 := 0;
                        s1 := 0; s2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                        s1 := vs * t1 + acc * t1 * t1 / 2;
                        s2 := 0;
                        s3 := s_all - s1;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                    s_all := s1 + s3;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                rvs := vs;
                vs := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 16 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_16
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_now_velocity : REAL;
    Axis_run_number : USINT;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_s1 : REAL;
    blend_s2 : REAL;
    blend_start_a : REAL;
    blend_start_pos : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    rs1 : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s_all : REAL;
    s_blend : REAL;
    s_rev : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t8 : REAL;
    t9 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    start_postion := start_postion + now_direction * rs1;
                    t_now := 0;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    start_postion := start_postion + now_direction * s_rev;
                    t_now := 0;
                ELSIF t_now &lt;= rt1 THEN
                    now_stage_vs := rvs;
                ELSIF t_now &lt;= rt1 + rt2 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2;
                ELSIF t_now &lt; rt1 + rt2 + rt3 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2 - jerk * rt1 * rt2;
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt;= t1 THEN
                        now_stage_vs := vs;
                    ELSIF t_now &lt;= t1 + t2 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2;
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2;
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2 + jerk * t1 * t2;
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2 - jerk * t1 * t2;
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 THEN
                        now_stage_vs := vmax;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                        now_stage_vs := vmax;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 + t7 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2 - jerk * t5 * t6;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2 - jerk * t7 * t8;
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2 + jerk * t7 * t8;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
            IF Axis_buffered_without_blending = 0 THEN
                IF (NOT jerk_mode AND t_now &gt; t1 AND t_now &lt; t_all) OR
                   (jerk_mode AND t_now &gt; t1 + t2 + t3 AND t_now &lt; t_all) THEN
                    IF jerk_mode THEN    // S型混成
                        IF t_now &lt;= t1 + t2 + t3 + t4 THEN
                            blend_start_a := 0;
                            s_blend := s_all - s1 - s2 - s3 - 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - t1 - t2 - t3);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                            blend_start_a := jerk * (t_now - t1 - t2 - t3 - t4);
                            s_blend := s_all - s1 - s2 - s3 - s4 - 
                                Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2 - t3 - t4);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                            blend_start_a := jerk * t5;
                            s_blend := s_all - s1 - s2 - s3 - s4 - s5 - // 这里 now_stage_vs 没有发生变化
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := 0,d_t := t_now - t1 - t2 - t3 - t4 - t5);
                        ELSE
                            blend_start_a := jerk * (t5 - (t_now - t1 - t2 - t3 - t4 - t5 - t6)); // 跟c代码不同，多t6
                            s_blend := s_all - s1 - s2 - s3 - s4 - s5 - s6 - 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - t1 - t2 - t3 - t4 - t5 - t6);
                        END_IF;
                        IF blend_start_a &lt;&gt; 0 THEN
                            t5 := blend_start_a / jerk;
                        ELSE
                            t5 := 0;
                        END_IF;
                        Axis_now_velocity := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
                        blend_start_t := t_now;
                        blend_start_v := RealAbs(Axis_now_velocity);
                        blend_start_pos := start_postion + s_all - s_blend;
                        blend_equal_vel := blend_start_v - blend_start_a * t5 + jerk * t5 * t5 / 2;
                        blend_s1 := Motion_Delta_S(vs := blend_start_v,acc := 0,dec := blend_start_a,jerk := jerk,d_t := t5);
                        s6 := s_blend - blend_s1 - blend_s2;
                        t6 := s6 / blend_equal_vel;
                        IF t6 &lt; 0 THEN
                            t6 := 0;    s6 := 0;
                            IF s_blend &lt;= blend_s1 THEN    // 直接减速都超距离
                                s_blend := blend_s1;
                                blend_s2 := 0;
                                t7 := 0;
                                t8 := 0;
                                t9 := 0;
                            END_IF;
                        END_IF;
                        t_all := blend_start_t + t5 + t6 + t7 + t8 + t9;
                    ELSE                 // 梯形混成
                        IF t_now &lt; t1 + t2 THEN
                            s_blend := s_all - s1 - Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := 0,d_t := UDINT_TO_REAL(t_now) - t1);
                            blend_equal_vel := vmax;
                        ELSE
                            s_blend := s_all - s1 - s2 - Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := UDINT_TO_REAL(t_now) - t1 - t2);
                            blend_equal_vel := vmax - dec * (UDINT_TO_REAL(t_now) - t1 - t2);
                        END_IF;
                        blend_start_t := t_now;
                        blend_start_pos := start_postion + s_all - s_blend;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                            t5 := (Axis_blending_v - blend_equal_vel) / acc;
                            s5 := Motion_Delta_S(vs := blend_equal_vel,acc := acc,dec := 0,jerk := 0,d_t := t5);
                        ELSE                                                       // 混承速度 &lt;= 当前速度
                            t5 := (blend_equal_vel - Axis_blending_v) / dec;
                            s5 := Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := dec,jerk := 0,d_t := t5);
                        END_IF;
                        s4 := s_blend - s5;
                        t4 := s4 / blend_equal_vel;
                        IF t4 &lt; 0 THEN
                            t4 := 0; s4 := 0;
                            IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                                t5 := (ESQR(blend_equal_vel * blend_equal_vel + 2 * acc * s_blend) - blend_equal_vel) / acc;
                            ELSE
                                t5 := (blend_equal_vel - ESQR(blend_equal_vel * blend_equal_vel + 2 * dec * s_blend)) / dec;
                            END_IF;
                        END_IF;
                        t_all := blend_start_t + t4 + t5;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 17 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_17
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Axis_numOut : USINT;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_state : USINT;
    execute_before : BOOL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF NOT Execute AND stage &lt;&gt; 3(* FBS_InBuffer *) AND stage &lt;&gt; 4(* FBS_Moving *) THEN
    stage := 0(* FBS_WaitExec *);
    execute_before := FALSE;
END_IF;
Axis_state := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 56) ;
IF (Axis_state = 0(* AS_Disabled *) OR Axis_state = 1(* AS_Errorstop *)) AND stage = 4(* FBS_Moving *) THEN
    stage := 0(* FBS_WaitExec *);
END_IF;
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
END_IF;
END_PROGRAM

===== BLOCK 18 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_18
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_relative_postion : REAL;
    acc : REAL;
    dec : REAL;
    execute_before : BOOL;
    jerk : REAL;
    pos : REAL;
    stage : USINT;
    vel : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        Axis_relative_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 96) ;
        vel := Velocity / 1000.0;
        acc := Acceleration / 1000000.0;
        dec := Deceleration / 1000000.0;
        jerk := Jerk / 1000000000.0;
        pos := Position - Axis_relative_postion;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 19 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_19
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    execute_before : BOOL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 20 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_20
VAR_INPUT
    Axis_num : USINT;
    BufferMode : USINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_now_motion_vel : REAL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            IF BufferMode = 2(* BM_Blendinglow *) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140); 
            END_IF;
            IF BufferMode = 3(* BFM_BlendingPrevious *) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140);
            END_IF;
            IF BufferMode = 4 (*BM_BlendingNext*) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140);
            END_IF;
            IF BufferMode = 5(*BM_BlendingHigh*) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140); 
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 21 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_21
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    BufferMode : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_busy : USINT;
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_relative_postion : REAL;
    Axis_run_next : USINT;
    dec : REAL;
    execute_before : BOOL;
    jerk : REAL;
    pos : REAL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        Axis_relative_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 96) ;
        dec := Deceleration / 1000000.0;
        jerk := Jerk / 1000000000.0;
        pos := Position - Axis_relative_postion;
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
        stage := 3(* FBS_CalcRoute *);
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            Axis_run_next := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 148);
            IF (BufferMode = 1 AND Axis_run_next &lt;&gt; 1) OR BufferMode &lt;&gt; 1 THEN
                stage := 2(* FBS_InBuffer *);
            END_IF;
        END_IF;
    END_IF;
END_IF;
IF stage = 2(* FBS_InBuffer *) THEN
    Axis_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 153);
    IF Axis_busy = 0 THEN
        stage := 3(* FBS_CalcRoute *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 22 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_22
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    dec : REAL;
    direction : INT;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    s_all : REAL;
    stage : USINT;
    t_now : UDINT;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
            END_IF;
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 23 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_23
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_numberF : USINT;
    s_rev : REAL;
    stage : USINT;
    start_postion : REAL;
    t_now : UDINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    start_postion := start_postion + now_direction * rs1;
                    t_now := 0;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    start_postion := start_postion + now_direction * s_rev;
                    t_now := 0;
                END_IF;
            END_IF;
        END_IF;
        t_now := t_now + 1;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 24 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_24
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    BufferMode : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_busy : USINT;
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_relative_postion : REAL;
    Axis_run_next : USINT;
    execute_before : BOOL;
    jerk : REAL;
    pos : REAL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        Axis_relative_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 96) ;
        jerk := Jerk / 1000000000.0;
        pos := Position - Axis_relative_postion;
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
        stage := 3(* FBS_CalcRoute *);
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            Axis_run_next := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 148);
            IF (BufferMode = 1 AND Axis_run_next &lt;&gt; 1) OR BufferMode &lt;&gt; 1 THEN
                stage := 2(* FBS_InBuffer *);
            END_IF;
        END_IF;
    END_IF;
END_IF;
IF stage = 2(* FBS_InBuffer *) THEN
    Axis_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 153);
    IF Axis_busy = 0 THEN
        stage := 3(* FBS_CalcRoute *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 25 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_25
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    jerk : REAL;
    jerk_mode : BOOL;
    pos : REAL;
    run_numberF : USINT;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    Axis_run_number := Axis_run_number MOD 255 + 1; // [1,255]
    run_numberF := Axis_run_number;
    start_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 176);
    IF pos &gt;= start_postion THEN
        s_all := pos - start_postion;
    ELSE
        s_all := start_postion - pos;
    END_IF;
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            Axis_now_acceleration := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 168);
        END_IF;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 26 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_26
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_run_number : USINT;
    run_numberF : USINT;
    s_blend : REAL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 27 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_27
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    BufferMode : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_busy : USINT;
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_relative_postion : REAL;
    Axis_run_next : USINT;
    execute_before : BOOL;
    jerk : REAL;
    pos : REAL;
    stage : USINT;
    vel : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
    ELSE
        Axis_relative_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 96) ;
        vel := Velocity / 1000.0;
        jerk := Jerk / 1000000000.0;
        pos := Position - Axis_relative_postion;
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
        stage := 3(* FBS_CalcRoute *);
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            Axis_run_next := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 148);
            IF (BufferMode = 1 AND Axis_run_next &lt;&gt; 1) OR BufferMode &lt;&gt; 1 THEN
                stage := 2(* FBS_InBuffer *);
            END_IF;
        END_IF;
    END_IF;
END_IF;
IF stage = 2(* FBS_InBuffer *) THEN
    Axis_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 153);
    IF Axis_busy = 0 THEN
        stage := 3(* FBS_CalcRoute *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 28 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_28
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    pos : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    start_postion : REAL;
    t4 : REAL;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    start_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 176);
    IF pos &gt;= start_postion THEN
        direction := 1;
        s_all := pos - start_postion;
    ELSE
        direction := -1;
        s_all := start_postion - pos;
    END_IF;
    vs := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
    IF vs &lt;= -0.004(* MINV *) THEN
        vs := -1.0 * vs;
        now_direction := -1;
    ELSIF vs &gt;= 0.004(* MINV *) THEN
        now_direction := 1;
    ELSE
        vs := 0;
        now_direction := direction;
    END_IF;
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
    IF s_all &lt;= 0.001(* MINP *) THEN
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                vs := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        s_acc := 0;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        s_acc := 0;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 29 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_29
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    pos : REAL;
    run_numberF : USINT;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    Axis_run_number := Axis_run_number MOD 255 + 1; // [1,255]
    run_numberF := Axis_run_number;
    start_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 176);
    IF pos &gt;= start_postion THEN
        direction := 1;
        s_all := pos - start_postion;
    ELSE
        direction := -1;
        s_all := start_postion - pos;
    END_IF;
    vs := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
    IF vs &lt;= -0.004(* MINV *) THEN
        vs := -1.0 * vs;
        now_direction := -1;
    ELSIF vs &gt;= 0.004(* MINV *) THEN
        now_direction := 1;
    ELSE
        vs := 0;
        now_direction := direction;
    END_IF;
    as := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 168);
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 30 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_30
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    run_mode : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                rvs := vs;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        vmax := vs;
                        t1 := 0; t2 := 0;
                        s1 := 0; s2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                        s1 := vs * t1 + acc * t1 * t1 / 2;
                        s2 := 0;
                        s3 := s_all - s1;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                    s_all := s1 + s3;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            Axis_now_acceleration := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 168);
            as := Axis_now_acceleration;
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                rvs := vs;
                vs := 0;
                as := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            as := RealAbs(as);
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 31 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_31
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_start_pos : REAL;
    blend_start_t : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    rs1 : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s_all : REAL;
    s_rev : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    Axis_taget_postion := start_postion + now_direction * rs1;
                END_IF;
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_taget_postion := start_postion + now_direction * s_all;
                    ELSIF t_now &lt; t1 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                        ELSE
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t_now);
                        END_IF;
                    ELSIF t_now &lt; t_all THEN
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 +
                            Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t_now - t1 - t2));
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSE
                        IF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                            Axis_taget_postion := blend_start_pos + now_direction * ( s4 +
                                Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := dec,jerk := 0,d_t := (t_now - blend_start_t - t4)));
                        END_IF;
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    Axis_taget_postion := start_postion + now_direction * s_rev;
                ELSIF t_now &lt;= rt1 + rt2 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2;
                    Axis_taget_postion := start_postion + now_direction * ( rs1 +
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - rt1));
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_taget_postion := start_postion + now_direction * s_all;
                    ELSIF t_now &lt;= t1 THEN
                        now_stage_vs := vs;
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                        ELSE
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := as,jerk := ( -1 * jerk),d_t := t_now);
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - t1));
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2 - jerk * t1 * t2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t1,jerk := jerk,d_t := t_now - t1 - t2));
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                        now_stage_vs := vmax;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2 - t3 - t4));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 + t7 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2 - jerk * t5 * t6;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 + s5 + s6 + 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - t1 - t2 - t3 - t4 - t5 - t6));
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 32 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_32
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    run_mode : USINT;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        vmax := vs;
                        t1 := 0; t2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                vs := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 33 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_33
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_now_velocity : REAL;
    Axis_run_number : USINT;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_s1 : REAL;
    blend_start_a : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    s_blend : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    t_now := 0;
                END_IF;
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    t_now := 0;
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
            IF Axis_buffered_without_blending = 0 THEN
                IF (NOT jerk_mode AND t_now &gt; t1 AND t_now &lt; t_all) OR
                   (jerk_mode AND t_now &gt; t1 + t2 + t3 AND t_now &lt; t_all) THEN
                    IF jerk_mode THEN    // S型混成
                        IF t_now &lt;= t1 + t2 + t3 + t4 THEN
                            blend_start_a := 0;
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                            blend_start_a := jerk * (t_now - t1 - t2 - t3 - t4);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                            blend_start_a := jerk * t5;
                        ELSE
                            blend_start_a := jerk * (t5 - (t_now - t1 - t2 - t3 - t4 - t5 - t6)); // 跟c代码不同，多t6
                        END_IF;
                        IF blend_start_a &lt;&gt; 0 THEN
                            t5 := blend_start_a / jerk;
                        ELSE
                            t5 := 0;
                        END_IF;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        Axis_now_velocity := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
                        blend_start_t := t_now;
                        blend_start_v := RealAbs(Axis_now_velocity);
                        blend_equal_vel := blend_start_v - blend_start_a * t5 + jerk * t5 * t5 / 2;
                        blend_s1 := Motion_Delta_S(vs := blend_start_v,acc := 0,dec := blend_start_a,jerk := jerk,d_t := t5);
                    ELSE                 // 梯形混成
                        IF t_now &lt; t1 + t2 THEN
                            blend_equal_vel := vmax;
                        ELSE
                            blend_equal_vel := vmax - dec * (UDINT_TO_REAL(t_now) - t1 - t2);
                        END_IF;
                        blend_start_t := t_now;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 34 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_34
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    run_mode : USINT;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        vmax := vs;
                        t1 := 0; t2 := 0;
                        s1 := 0; s2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                        s1 := vs * t1 + acc * t1 * t1 / 2;
                        s2 := 0;
                        s3 := s_all - s1;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                    s_all := s1 + s3;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                s_all := s_all + s_rev;
                vs := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    IF s_dec &gt;= s_all THEN
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 35 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_35
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    acc : REAL;
    blend_equal_vel : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s_all : REAL;
    s_blend : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    t_now := 0;
                END_IF;
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt; t1 + t2 THEN
                        Axis_taget_postion := start_postion + now_direction * ( s1 + 
                            Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := 0,d_t := t_now - t1));
                    ELSIF t_now &lt; t_all THEN
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 +
                            Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t_now - t1 - t2));
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    t_now := 0;
                END_IF;
            END_IF;
        END_IF;
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
            IF Axis_buffered_without_blending = 0 THEN
                IF (NOT jerk_mode AND t_now &gt; t1 AND t_now &lt; t_all) OR
                   (jerk_mode AND t_now &gt; t1 + t2 + t3 AND t_now &lt; t_all) THEN
                    IF jerk_mode THEN    // S型混成
                        IF t_now &lt;= t1 + t2 + t3 + t4 THEN
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                            s_blend := s_all - s1 - s2 - s3 - s4 - 
                                Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2 - t3 - t4);
                        END_IF;
                    ELSE                 // 梯形混成
                        IF t_now &lt; t1 + t2 THEN
                            s_blend := s_all - s1 - Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := 0,d_t := UDINT_TO_REAL(t_now) - t1);
                            blend_equal_vel := vmax;
                        ELSE
                            s_blend := s_all - s1 - s2 - Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := UDINT_TO_REAL(t_now) - t1 - t2);
                            blend_equal_vel := vmax - dec * (UDINT_TO_REAL(t_now) - t1 - t2);
                        END_IF;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 36 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_36
VAR_INPUT
    Axis_num : USINT;
    Execute : BOOL;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Axis_numOut : USINT;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    execute_before : BOOL;
    s_blend : REAL;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF NOT Execute AND stage &lt;&gt; 3(* FBS_InBuffer *) AND stage &lt;&gt; 4(* FBS_Moving *) THEN
    Axis_numOut := Axis_num;
    Done := FALSE;
    Active := FALSE;
    Busy := FALSE;
    CommandAborted := FALSE;
    Error := FALSE;
    ErrorID := 0(* ER_NoError *);
    stage := 0(* FBS_WaitExec *);
    execute_before := FALSE;
    s_blend := 0;
END_IF;
END_PROGRAM

===== BLOCK 37 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_37
VAR_INPUT
    Axis_num : USINT;
    Execute : BOOL;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Axis_numOut : USINT;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_state : USINT;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF NOT Execute AND stage &lt;&gt; 3(* FBS_InBuffer *) AND stage &lt;&gt; 4(* FBS_Moving *) THEN
    stage := 0(* FBS_WaitExec *);
END_IF;
Axis_state := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 56) ;
IF (Axis_state = 0(* AS_Disabled *) OR Axis_state = 1(* AS_Errorstop *)) AND stage = 4(* FBS_Moving *) THEN
    CommandAborted := TRUE;
    Error := TRUE;
    ErrorID := 16#01(* ER_StateError *);
    stage := 0(* FBS_WaitExec *);
END_IF;
END_PROGRAM

===== BLOCK 38 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_38
VAR_INPUT
    Acceleration : REAL;
    Axis_num : USINT;
    BufferMode : USINT;
    Deceleration : REAL;
    Execute : BOOL;
    Jerk : REAL;
    Position : REAL;
    Velocity : REAL;
END_VAR
VAR_OUTPUT
    Error : BOOL;
    ErrorID : UINT;
END_VAR
VAR
    Axis_maxacc : REAL;
    Axis_maxdec : REAL;
    Axis_maxjerk : REAL;
    Axis_maxvel : REAL;
    Axis_relative_postion : REAL;
    Axis_state : USINT;
    acc : REAL;
    dec : REAL;
    execute_before : BOOL;
    jerk : REAL;
    pos : REAL;
    stage : USINT;
    vel : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 0(* FBS_WaitExec *) AND Execute AND NOT execute_before THEN
    Axis_maxvel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 36); 
    Axis_maxacc := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 40); 
    Axis_maxdec := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 44); 
    Axis_maxjerk := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 48); 
    IF Axis_num &gt;= 50(* AXIS_MAXNUM *) OR Velocity &lt;= 0.004 (* MINV *) OR Velocity &gt; Axis_maxvel OR
       Acceleration &lt;= 0.004 (* MINV *) OR Acceleration &gt; Axis_maxacc OR
       Deceleration &lt;= 0.004 (* MINV *) OR Deceleration &gt; Axis_maxdec OR
       Jerk &lt; 0 OR Jerk &gt; Axis_maxjerk 
    THEN
        Error := TRUE;
        ErrorID := 16#02(* ER_ParameterError *);
        debug_ub := F_debug_print_ub(26); debug_ub := F_debug_printl_ub(1);   // 26_1
        debug_ub := F_debug_printl_real(Axis_num);
        debug_ub := F_debug_print_real(Velocity); debug_ub := F_debug_printl_real(Axis_maxvel);
        debug_ub := F_debug_print_real(Acceleration); debug_ub := F_debug_printl_real(Axis_maxacc);
        debug_ub := F_debug_print_real(Deceleration); debug_ub := F_debug_printl_real(Axis_maxdec);
        debug_ub := F_debug_print_real(Jerk); debug_ub := F_debug_printl_real(Axis_maxjerk);
    ELSIF Axis_state = 0(* MC_Disabled *) OR Axis_state = 1(* MC_Errorstop *) OR Axis_state = 4(* MC_Stopping *) THEN
        Error := TRUE;
        ErrorID := 16#01(* ER_StateError *);
    ELSE
        Error := FALSE;
        ErrorID := 16#00(* ER_NoError *);
        Axis_relative_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 96) ;
        vel := Velocity / 1000.0;
        acc := Acceleration / 1000000.0;
        dec := Deceleration / 1000000.0;
        jerk := Jerk / 1000000000.0;
        pos := Position - Axis_relative_postion;
        stage := 1(* FBS_WaitBuffer *);
    END_IF;
END_IF;
IF stage = 1(* FBS_WaitBuffer *)  THEN
END_IF;
END_PROGRAM

===== BLOCK 39 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_39
VAR_INPUT
    Axis_num : USINT;
    BufferMode : USINT;
END_VAR
VAR
    Axis_buffer_busy : USINT;
    Axis_busy : USINT;
    Axis_now_motion_vel : REAL;
    Axis_run_next : USINT;
    WRAxisPar_Res : BOOL;
    stage : USINT;
    vel : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 1(* FBS_WaitBuffer *)  THEN
    IF BufferMode = 0(* BM_Aborting *) THEN
        stage := 3(* FBS_CalcRoute *);
    ELSE
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 0 THEN
            Axis_run_next := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 148);
            IF BufferMode = 1(* BM_Buffered *) AND Axis_run_next &lt;&gt; 1 THEN
                WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 152, Data := 1);
            END_IF;
            IF BufferMode = 2(* BM_Blendinglow *) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140); 
                IF Axis_now_motion_vel &gt; vel THEN
                    WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := vel);
                ELSE
                    WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := Axis_now_motion_vel);
                END_IF;
            END_IF;
            IF BufferMode = 3(* BFM_BlendingPrevious *) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140);
                WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := Axis_now_motion_vel);
            END_IF;
            IF BufferMode = 4 (*BM_BlendingNext*) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140);
                WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := vel);
            END_IF;
            IF BufferMode = 5(*BM_BlendingHigh*) THEN
                Axis_now_motion_vel := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 140); 
                IF Axis_now_motion_vel &lt; vel THEN
                    WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := vel);
                ELSE
                    WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := Axis_now_motion_vel);
                END_IF;
            END_IF;
            IF (BufferMode = 1 AND Axis_run_next &lt;&gt; 1) OR BufferMode &lt;&gt; 1 THEN
                WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 155, Data := 1);
                stage := 2(* FBS_InBuffer *);
            END_IF;
        END_IF;
    END_IF;
END_IF;
IF stage = 2(* FBS_InBuffer *) THEN
    Axis_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 153);
    IF Axis_busy = 0 THEN
        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 155, Data := 0);
        stage := 3(* FBS_CalcRoute *);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 40 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_40
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    WRAxisPar_Res : BOOL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    pos : REAL;
    run_numberF : USINT;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
    vel : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    Axis_run_number := Axis_run_number MOD 255 + 1; // [1,255]
    WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 64, Data := Axis_run_number);
    run_numberF := Axis_run_number;
    WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 1);
    WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 152, Data := 0);
    start_postion := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 176);
    IF pos &gt;= start_postion THEN
        direction := 1;
        s_all := pos - start_postion;
    ELSE
        direction := -1;
        s_all := start_postion - pos;
    END_IF;
    vs := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
    IF vs &lt;= -0.004(* MINV *) THEN
        vs := -1.0 * vs;
        now_direction := -1;
    ELSIF vs &gt;= 0.004(* MINV *) THEN
        now_direction := 1;
    ELSE
        vs := 0;
        now_direction := direction;
    END_IF;
    as := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 168);
    IF jerk &gt; 0 THEN
        jerk_mode := TRUE;
    ELSE
        jerk_mode := FALSE;
    END_IF;
    WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 144, Data := pos);
    WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 140, Data := vel);
    IF s_all &lt;= 0.001(* MINP *) THEN
        Done := TRUE;
        CommandAborted := FALSE;
        Busy := FALSE;
        Active := FALSE;
        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 0);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 41 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_41
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    FB_S_Type_Motion_Par_Calc_3_Segments1 : FB_S_Type_Motion_Par_Calc_3_Segments;
    FB_S_Type_Motion_Par_Calc_Fix_S1 : FB_S_Type_Motion_Par_Calc_Fix_S;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rs2 : REAL;
    rs3 : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s7 : REAL;
    s_acc : REAL;
    s_all : REAL;
    s_dec : REAL;
    s_rev : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vel : REAL;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 3(* FBS_CalcRoute *) THEN
    IF s_all &lt;= 0.001(* MINP *) THEN
        stage := 0(* FBS_WaitExec *);
    ELSE
        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 56, Data := 5(* AS_Discrete_Motion *));
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                rt1 := vs / dec;
                rs1 := vs * vs / dec / 2;
                s_all := s_all + rs1;
                rvs := vs;
                vs := 0;
            END_IF;
            IF vs &lt; vel - 0.004(* MINV *) THEN    // 运动初速度 &lt; 运动目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                t1 := (vmax - vs) / acc;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t3 := vs / dec;
                    s3 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t3);
                    IF s_all &lt;= s3 THEN    // 直接减速都超距离
                        vmax := vs;
                        t1 := 0; t2 := 0;
                        s1 := 0; s2 := 0;
                        s_all := s3;
                    ELSE
                        vmax := ESQR(vs * vs - (acc * vs * vs - 2 * acc * dec * s_all) / (acc + dec));
                        t1 := (vmax - vs) / acc;
                        t2 := 0;
                        t3 := vmax / dec;
                        s1 := vs * t1 + acc * t1 * t1 / 2;
                        s2 := 0;
                        s3 := s_all - s1;
                    END_IF;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
            IF vs &gt;= vel - 0.004(* MINV *) THEN   // 运动初速度 &gt;= 运动目标速度
                run_mode := 2(* RM_DEC_EQU_DEC *);
                vmax := vel;
                t1 := (vs - vmax) / dec;
                t3 := vmax / dec;
                s1 := Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t1);
                s3 := Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t3);
                s2 := s_all - s1 - s3;
                t2 := s2 / vmax;
                IF t2 &lt; 0 THEN
                    t2 := 0; s2 := 0;
                    s_all := s1 + s3;
                END_IF;
                t_all := t1 + t2 + t3;
            END_IF;
        ELSE                     // S 型模式
            Axis_now_acceleration := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 168);
            as := Axis_now_acceleration;
            IF direction &lt;&gt; now_direction THEN    // 目标方向与当前速度方向不同,先减速至0
                FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vs,as := as,vt := 0,acc := 0,dec := dec,jerk := jerk,
                    t1 =&gt; rt1,t2 =&gt; rt2,t3 =&gt; rt3,s1 =&gt; rs1,s2 =&gt; rs2,s3 =&gt; rs3,t_3seg =&gt; ,s_3seg =&gt; s_rev);
                s_all := s_all + s_rev;
                rvs := vs;
                vs := 0;
                as := 0;
            END_IF;
            IF vs &lt; vel THEN    // 初速度 &lt; 目标速度
                run_mode := 1(* RM_ACC_EQU_DEC *);
                vmax := vel;
                FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vs,as := as,vt := vmax,acc := acc,dec := 0,jerk := jerk,
                    t1 =&gt; t1,t2 =&gt; t2,t3 =&gt; t3,s1 =&gt; s1,s2 =&gt; s2,s3 =&gt; s3,t_3seg =&gt; ,s_3seg =&gt; s_acc );
                FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vmax,as := 0,vt := 0,acc := 0,dec := dec,jerk := jerk,
                    t1 =&gt; t5,t2 =&gt; t6,t3 =&gt; t7,s1 =&gt; s5,s2 =&gt; s6,s3 =&gt; s7,t_3seg =&gt; ,s_3seg =&gt; s_dec );
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN    // 达不到最大速度
                    FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vs,as := as,vt := 0,acc := 0,dec := dec,jerk := jerk,
                        t1 =&gt; t5,t2 =&gt; t6,t3 =&gt; t7,s1 =&gt; s5,s2 =&gt; s6,s3 =&gt; s7,t_3seg =&gt; t_all,s_3seg =&gt; s_dec );
                    IF s_dec &gt;= s_all THEN    // 直接减速都超出预定距离
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    ELSE                      // 直接减不会超过限度
                        FB_S_Type_Motion_Par_Calc_Fix_S1(vs := vs,as := as,vm := vel,vt := 0,acc := acc,dec := dec,jerk := jerk,s_all := s_all,
                            vmax =&gt; vmax,t1 =&gt; t1,t2 =&gt; t2,t3 =&gt; t3,t4 =&gt; t4,t5 =&gt; t5,t6 =&gt; t6,t7 =&gt; t7,
                            s1 =&gt; s1,s2 =&gt; s2,s3 =&gt; s3,s4 =&gt; s4,s5 =&gt; s5,s6 =&gt; s6,s7 =&gt; s7,t_all =&gt; t_all); 
                    END_IF;
                END_IF;
            END_IF;
            IF vs &gt;= vel THEN       // 初速度 &gt;= 目标速度
                run_mode := 2(*RM_DEC_EQU_DEC*);
                vmax := vel;
                FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vs,as := as,vt := vmax,acc := 0,dec := dec,jerk := jerk,
                    t1 =&gt; t1,t2 =&gt; t2,t3 =&gt; t3,s1 =&gt; s1,s2 =&gt; s2,s3 =&gt; s3,t_3seg =&gt; ,s_3seg =&gt; s_acc);
                FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vmax,as := 0,vt := 0,acc := 0,dec := dec,jerk := jerk,
                    t1 =&gt; t5,t2 =&gt; t6,t3 =&gt; t7,s1 =&gt; s5,s2 =&gt; s6,s3 =&gt; s7,t_3seg =&gt; ,s_3seg =&gt; s_dec);
                s4 := s_all - s_acc - s_dec;
                t4 := s4 / vmax;
                t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                IF t4 &lt; 0 THEN
                    FB_S_Type_Motion_Par_Calc_3_Segments1(vs := vs,as := as,vt := 0,acc := 0,dec := dec,jerk := jerk,
                        t1 =&gt; t5,t2 =&gt; t6,t3 =&gt; t7,s1 =&gt; s5,s2 =&gt; s6,s3 =&gt; s7,t_3seg =&gt; ,s_3seg =&gt; s_dec);
                    IF s_dec &gt;= s_all THEN
                        s_all := s_dec;
                        t1 := 0; s1 := 0;
                        t2 := 0; s2 := 0;
                        t3 := 0; s3 := 0;
                        t4 := 0; s4 := 0;
                        s_acc := 0;
                        vmax := vs;
                        t_all := t1 + t2 + t3 + t4 + t5 + t6 + t7;
                    ELSE
                        FB_S_Type_Motion_Par_Calc_Fix_S1(vs := vs,as := as,vm := vel,vt := 0,acc := 0,dec := dec,jerk := jerk,s_all := s_all,
                            vmax =&gt; vmax,t1 =&gt; t1,t2 =&gt; t2,t3 =&gt; t3,t4 =&gt; t4,t5 =&gt; t5,t6 =&gt; t6,t7 =&gt; t7,
                            s1 =&gt; s1,s2 =&gt; s2,s3 =&gt; s3,s4 =&gt; s4,s5 =&gt; s5,s6 =&gt; s6,s7 =&gt; s7,t_all =&gt; t_all); 
                    END_IF;
                END_IF;
            END_IF;
            as := RealAbs(as);
        END_IF;
        t_now := 1;
        stage := 4(* FBS_Moving *);
        debug_ub := F_debug_print_ub(26); debug_ub := F_debug_printl_ub(2);   // 26_2
        debug_ub := F_debug_print_ub(Axis_num); debug_ub := F_debug_printl_real(as);
        debug_ub := F_debug_print_real(t1); debug_ub := F_debug_print_real(t2); debug_ub := F_debug_print_real(t3); 
        debug_ub := F_debug_print_real(t4); debug_ub := F_debug_print_real(t5); debug_ub := F_debug_print_real(t6); debug_ub := F_debug_printl_real(t7);
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 42 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_42
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    run_numberF : USINT;
    stage : USINT;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
        CommandAborted := TRUE;
        run_numberF := 0;
        Busy := FALSE;
        Active := FALSE;
        Done := FALSE;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 43 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_43
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    rs1 : REAL;
    rt1 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    stage : USINT;
    start_postion : REAL;
    t_all : REAL;
    t_now : UDINT;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
        stage := 0(* FBS_WaitExec *);
    ELSE
        Busy := TRUE;
        Active := TRUE;
        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 1);
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    start_postion := start_postion + now_direction * rs1;
                    now_direction := direction;
                    t_now := 0;
                ELSE
                    Axis_taget_postion := start_postion + now_direction *
                        Motion_Delta_S(vs := rvs,acc := 0,dec := dec,jerk := 0,d_t := t_now); 
                END_IF;
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 148, Data := 1);
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 0);
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 44 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_44
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    run_mode : USINT;
    run_numberF : USINT;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                        Axis_taget_postion := start_postion + now_direction * s_all;
                    ELSIF t_now &lt; t1 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t_now); 
                        ELSE
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t_now);
                        END_IF;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 45 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_45
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_start_pos : REAL;
    blend_start_t : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    rs1 : REAL;
    rs2 : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    s4 : REAL;
    s_rev : REAL;
    stage : USINT;
    start_postion : REAL;
    t4 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 148, Data := 1);
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 0);
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSIF t_now &lt;= blend_start_t + t4 THEN
                        Axis_taget_postion := blend_start_pos + now_direction * 
                            Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := 0,jerk := 0,d_t := (t_now - blend_start_t));
                    ELSE
                        IF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                            Axis_taget_postion := blend_start_pos + now_direction * ( s4 +
                                Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := dec,jerk := 0,d_t := (t_now - blend_start_t - t4)));
                        ELSE
                            Axis_taget_postion := blend_start_pos + now_direction * ( s4 +
                                Motion_Delta_S(vs := blend_equal_vel,acc := acc,dec := 0,jerk := 0,d_t := (t_now - blend_start_t - t4)));
                        END_IF;
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    Axis_taget_postion := start_postion + now_direction * s_rev;
                    start_postion := start_postion + now_direction * s_rev;
                    now_direction := direction;
                    t_now := 0;
                ELSIF t_now &lt;= rt1 THEN
                    now_stage_vs := rvs;
                    Axis_taget_postion := start_postion + now_direction *
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now);
                ELSIF t_now &lt;= rt1 + rt2 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2;
                    Axis_taget_postion := start_postion + now_direction * ( rs1 +
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - rt1));
                ELSIF t_now &lt; rt1 + rt2 + rt3 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2 - jerk * rt1 * rt2;
                    Axis_taget_postion := start_postion + now_direction * ( rs1 + rs2 + 
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * rt1,jerk := jerk,d_t := t_now - rt1 - rt2));
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 148, Data := 1);
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 0);
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 46 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_46
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    acc : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s_all : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                        Axis_taget_postion := start_postion + now_direction * s_all;
                    ELSIF t_now &lt;= t1 THEN
                        now_stage_vs := vs;
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := now_stage_vs,acc := as,dec := 0,jerk := jerk,d_t := t_now); 
                        ELSE
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := as,jerk := ( -1 * jerk),d_t := t_now);
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 +
                                Motion_Delta_S(vs := now_stage_vs,acc := acc,dec := 0,jerk := 0,d_t := t_now - t1));    // 这里可以填acc是因为到达匀加速阶段时的加速度一定达到预设值
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - t1));
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2 + jerk * t1 * t2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + 
                                Motion_Delta_S(vs := now_stage_vs,acc := jerk * t1,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2));
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2 - jerk * t1 * t2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t1,jerk := jerk,d_t := t_now - t1 - t2));
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 THEN
                        now_stage_vs := vmax;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - t1 - t2 - t3));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                        now_stage_vs := vmax;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2 - t3 - t4));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 + s5 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := 0,d_t := t_now - t1 - t2 - t3 - t4 - t5));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 + t7 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2 - jerk * t5 * t6;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 + s5 + s6 + 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - t1 - t2 - t3 - t4 - t5 - t6));
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 47 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_47
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_s1 : REAL;
    blend_start_a : REAL;
    blend_start_pos : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    s6 : REAL;
    s7 : REAL;
    s8 : REAL;
    stage : USINT;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t8 : REAL;
    t9 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 148, Data := 1);
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 0);
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                        Axis_taget_postion := blend_start_pos + now_direction * 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := blend_start_a,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - blend_start_t);
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - blend_start_t - t5));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - blend_start_t - t5 - t6)); 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - blend_start_t - t5 - t6 - t7));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2 - jerk * t7 * t8;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 + s8 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t7,jerk := jerk,d_t := t_now - blend_start_t - t5 - t6 - t7 - t8));
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                        Busy := FALSE;
                        Active := FALSE;
                        Done := TRUE;
                        CommandAborted := FALSE;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 48 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_48
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_now_velocity : REAL;
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    FB_S_Type_Motion_Par_Calc_3_Segments1 : FB_S_Type_Motion_Par_Calc_3_Segments;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_s1 : REAL;
    blend_s2 : REAL;
    blend_start_a : REAL;
    blend_start_pos : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s7 : REAL;
    s8 : REAL;
    s9 : REAL;
    s_all : REAL;
    s_blend : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t8 : REAL;
    t9 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                        stage := 0;
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 148, Data := 1);
                        WRAxisPar_Res := MC_WrAxisPar_UB(AxisNum := Axis_num, AddrOffset := 153, Data := 0);
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                        Axis_taget_postion := blend_start_pos + now_direction * 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := blend_start_a,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - blend_start_t);
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - blend_start_t - t5));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := jerk,d_t := t_now - blend_start_t - t5 - t6)); 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 +
                                Motion_Delta_S(vs := now_stage_vs,acc := acc,dec := 0,jerk := 0,d_t := t_now - blend_start_t - t5 - t6 - t7));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2 + jerk * t7 * t8;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 + s8 +
                                Motion_Delta_S(vs := now_stage_vs,acc := jerk * t7,dec := 0,jerk := ( -1 * jerk),d_t := t_now - blend_start_t - t5 - t6 - t7 - t8));
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
            IF Axis_buffered_without_blending = 0 THEN
                IF (NOT jerk_mode AND t_now &gt; t1 AND t_now &lt; t_all) OR
                   (jerk_mode AND t_now &gt; t1 + t2 + t3 AND t_now &lt; t_all) THEN
                    IF jerk_mode THEN    // S型混成
                        IF t_now &lt;= t1 + t2 + t3 + t4 THEN
                            blend_start_a := 0;
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                            blend_start_a := jerk * (t_now - t1 - t2 - t3 - t4);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                            blend_start_a := jerk * t5;
                        ELSE
                            blend_start_a := jerk * (t5 - (t_now - t1 - t2 - t3 - t4 - t5 - t6)); // 跟c代码不同，多t6
                        END_IF;
                        IF blend_start_a &lt;&gt; 0 THEN
                            t5 := blend_start_a / jerk;
                        ELSE
                            t5 := 0;
                        END_IF;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        Axis_now_velocity := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
                        blend_start_t := t_now;
                        blend_start_v := RealAbs(Axis_now_velocity);
                        blend_equal_vel := blend_start_v - blend_start_a * t5 + jerk * t5 * t5 / 2;
                        IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                            run_mode := 4(* RM_BLENDING_EQU_ACC *);
                            FB_S_Type_Motion_Par_Calc_3_Segments1(vs := blend_equal_vel,vt := Axis_blending_v,acc := acc,dec := 0,jerk := jerk,
                                t1 =&gt; t7,t2 =&gt; t8,t3 =&gt; t9,s1 =&gt; s7,s2 =&gt; s8,s3 =&gt; s9,t_3seg =&gt; ,s_3seg =&gt; blend_s2);
                        ELSE                                                       // 混承速度 &lt;= 当前速度
                            run_mode := 3(* RM_BLENDING_EQU_DEC *);
                            FB_S_Type_Motion_Par_Calc_3_Segments1(vs := blend_equal_vel,vt := Axis_blending_v,acc := 0,dec := dec,jerk := jerk,
                                t1 =&gt; t7,t2 =&gt; t8,t3 =&gt; t9,s1 =&gt; s7,s2 =&gt; s8,s3 =&gt; s9,t_3seg =&gt; ,s_3seg =&gt; blend_s2);
                        END_IF;
                    ELSE                 // 梯形混成
                        IF t_now &lt; t1 + t2 THEN
                            s_blend := s_all - s1 - Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := 0,d_t := UDINT_TO_REAL(t_now) - t1);
                            blend_equal_vel := vmax;
                        ELSE
                            s_blend := s_all - s1 - s2 - Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := UDINT_TO_REAL(t_now) - t1 - t2);
                            blend_equal_vel := vmax - dec * (UDINT_TO_REAL(t_now) - t1 - t2);
                        END_IF;
                        blend_start_t := t_now;
                        blend_start_pos := start_postion + s_all - s_blend;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                            run_mode := 4(* RM_BLENDING_EQU_ACC *);
                            t5 := (Axis_blending_v - blend_equal_vel) / acc;
                            s5 := Motion_Delta_S(vs := blend_equal_vel,acc := acc,dec := 0,jerk := 0,d_t := t5);
                        ELSE                                                       // 混承速度 &lt;= 当前速度
                            run_mode := 3(* RM_BLENDING_EQU_DEC *);
                            t5 := (blend_equal_vel - Axis_blending_v) / dec;
                            s5 := Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := dec,jerk := 0,d_t := t5);
                        END_IF;
                        s4 := s_blend - s5;
                        t4 := s4 / blend_equal_vel;
                        IF t4 &lt; 0 THEN
                            t4 := 0; s4 := 0;
                            IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                                t5 := (ESQR(blend_equal_vel * blend_equal_vel + 2 * acc * s_blend) - blend_equal_vel) / acc;
                            ELSE
                                t5 := (blend_equal_vel - ESQR(blend_equal_vel * blend_equal_vel + 2 * dec * s_blend)) / dec;
                            END_IF;
                            s5 := s_blend;
                        END_IF;
                        t_all := blend_start_t + t4 + t5;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        t_now := t_now + 1;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 49 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_49
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_buffer_busy : USINT;
    Axis_buffered_without_blending : USINT;
    Axis_now_velocity : REAL;
    Axis_run_number : USINT;
    FB_S_Type_Motion_Par_Calc_Fix_S1 : FB_S_Type_Motion_Par_Calc_Fix_S;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_s1 : REAL;
    blend_s2 : REAL;
    blend_start_a : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s7 : REAL;
    s8 : REAL;
    s9 : REAL;
    s_all : REAL;
    s_blend : REAL;
    stage : USINT;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t8 : REAL;
    t9 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    t_now := 0;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    t_now := 0;
                ELSIF t_now &lt;= rt1 THEN
                    now_stage_vs := rvs;
                ELSIF t_now &lt;= rt1 + rt2 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2;
                ELSIF t_now &lt; rt1 + rt2 + rt3 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2 - jerk * rt1 * rt2;
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt;= t1 THEN
                        now_stage_vs := vs;
                    ELSIF t_now &lt;= t1 + t2 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2;
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2;
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2 + jerk * t1 * t2;
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2 - jerk * t1 * t2;
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 THEN
                        now_stage_vs := vmax;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                        now_stage_vs := vmax;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 + t7 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2 - jerk * t5 * t6;
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2 - jerk * t7 * t8;
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2; 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2 + jerk * t7 * t8;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        Axis_buffer_busy := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 155);
        IF Axis_buffer_busy = 1 AND s_blend = 0 THEN    // 缓存中有内容需要进行混成计算
            Axis_buffered_without_blending := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 152);
            IF Axis_buffered_without_blending = 0 THEN
                IF (NOT jerk_mode AND t_now &gt; t1 AND t_now &lt; t_all) OR
                   (jerk_mode AND t_now &gt; t1 + t2 + t3 AND t_now &lt; t_all) THEN
                    IF jerk_mode THEN    // S型混成
                        IF t_now &lt;= t1 + t2 + t3 + t4 THEN
                            blend_start_a := 0;
                            s_blend := s_all - s1 - s2 - s3 - 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - t1 - t2 - t3);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                            blend_start_a := jerk * (t_now - t1 - t2 - t3 - t4);
                            s_blend := s_all - s1 - s2 - s3 - s4 - 
                                Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2 - t3 - t4);
                        ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                            blend_start_a := jerk * t5;
                            s_blend := s_all - s1 - s2 - s3 - s4 - s5 - // 这里 now_stage_vs 没有发生变化
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := 0,d_t := t_now - t1 - t2 - t3 - t4 - t5);
                        ELSE
                            blend_start_a := jerk * (t5 - (t_now - t1 - t2 - t3 - t4 - t5 - t6)); // 跟c代码不同，多t6
                            s_blend := s_all - s1 - s2 - s3 - s4 - s5 - s6 - 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - t1 - t2 - t3 - t4 - t5 - t6);
                        END_IF;
                        IF blend_start_a &lt;&gt; 0 THEN
                            t5 := blend_start_a / jerk;
                        ELSE
                            t5 := 0;
                        END_IF;
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132);
                        Axis_now_velocity := MC_RdAxisPar_FL(AxisNum := Axis_num,AddrOffset := 104);
                        blend_start_t := t_now;
                        blend_start_v := RealAbs(Axis_now_velocity);
                        blend_equal_vel := blend_start_v - blend_start_a * t5 + jerk * t5 * t5 / 2;
                        blend_s1 := Motion_Delta_S(vs := blend_start_v,acc := 0,dec := blend_start_a,jerk := jerk,d_t := t5);
                        s6 := s_blend - blend_s1 - blend_s2;
                        t6 := s6 / blend_equal_vel;
                        IF t6 &lt; 0 THEN
                            t6 := 0;    s6 := 0;
                            IF s_blend &lt;= blend_s1 THEN    // 直接减速都超距离
                                s_blend := blend_s1;
                                t7 := 0;
                                t8 := 0;
                                t9 := 0;
                                WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num,AddrOffset := 132,Data := blend_equal_vel);
                            ELSE    // 二分查找最大能到的混成速度
                                IF Axis_blending_v &gt; blend_equal_vel - 0.004(* MINV *) THEN  // 混承速度 &gt; 当前速度
                                    FB_S_Type_Motion_Par_Calc_Fix_S1(vs := blend_equal_vel,vm := Axis_blending_v,vt := blend_equal_vel,acc := acc,dec := acc,jerk := jerk,    // 对称，dec = acc
                                        s_all := (s_blend - blend_s1) * 2,vmax =&gt; Axis_blending_v,t1 =&gt; t7,t2 =&gt; t8,t3 =&gt; t9,t4 =&gt; ,t5 =&gt; ,t6 =&gt; ,t7 =&gt; ,
                                        s1 =&gt; s7,s2 =&gt; s8,s3 =&gt; s9,s4 =&gt; ,s5 =&gt; ,s6 =&gt; ,s7 =&gt; ,t_all =&gt; );
                                ELSE                                                       // 混承速度 &lt;= 当前速度
                                    FB_S_Type_Motion_Par_Calc_Fix_S1(vs := blend_equal_vel,vm := Axis_blending_v,vt := Axis_blending_v,acc := 0,dec := dec,jerk := jerk,
                                        s_all := (s_blend - blend_s1),vmax =&gt; Axis_blending_v,t1 =&gt; t7,t2 =&gt; t8,t3 =&gt; t9,t4 =&gt; ,t5 =&gt; ,t6 =&gt; ,t7 =&gt; ,
                                        s1 =&gt; s7,s2 =&gt; s8,s3 =&gt; s9,s4 =&gt; ,s5 =&gt; ,s6 =&gt; ,s7 =&gt; ,t_all =&gt; );
                                END_IF;
                                WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 132, Data := Axis_blending_v);
                            END_IF;
                        END_IF;
                        t_all := blend_start_t + t5 + t6 + t7 + t8 + t9;
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
    END_IF;
END_IF;
END_PROGRAM

===== BLOCK 50 =====

PROGRAM MC_MoveAbsolute_Init_Acc_BLOCK_50
VAR_INPUT
    Axis_num : USINT;
END_VAR
VAR_OUTPUT
    Active : BOOL;
    Busy : BOOL;
    CommandAborted : BOOL;
    Done : BOOL;
END_VAR
VAR
    Axis_blending_v : REAL;
    Axis_run_number : USINT;
    Axis_taget_postion : REAL;
    WRAxisPar_Res : BOOL;
    acc : REAL;
    blend_equal_vel : REAL;
    blend_s1 : REAL;
    blend_start_a : REAL;
    blend_start_pos : REAL;
    blend_start_t : REAL;
    blend_start_v : REAL;
    dec : REAL;
    direction : INT;
    jerk : REAL;
    jerk_mode : BOOL;
    now_direction : INT;
    now_stage_vs : REAL;
    rs1 : REAL;
    rs2 : REAL;
    rt1 : REAL;
    rt2 : REAL;
    rt3 : REAL;
    run_mode : USINT;
    run_numberF : USINT;
    rvs : REAL;
    s1 : REAL;
    s2 : REAL;
    s3 : REAL;
    s4 : REAL;
    s5 : REAL;
    s6 : REAL;
    s7 : REAL;
    s8 : REAL;
    s_all : REAL;
    s_rev : REAL;
    stage : USINT;
    start_postion : REAL;
    t1 : REAL;
    t2 : REAL;
    t3 : REAL;
    t4 : REAL;
    t5 : REAL;
    t6 : REAL;
    t7 : REAL;
    t8 : REAL;
    t9 : REAL;
    t_all : REAL;
    t_now : UDINT;
    vmax : REAL;
    vs : REAL;
END_VAR

(* ===== Functional body from original code ===== *)
IF stage = 4(* FBS_Moving *) THEN
    Axis_run_number := MC_RdAxisPar_UB(AxisNum := Axis_num,AddrOffset := 64);
    IF Axis_run_number &lt;&gt; run_numberF THEN    // 功能块被打断
    ELSE
        IF NOT jerk_mode THEN    // 梯形模式
            IF direction &lt;&gt; now_direction THEN
                IF t_now &gt;= rt1 THEN
                    Axis_taget_postion := start_postion + now_direction * rs1;
                ELSE
                    Axis_taget_postion := start_postion + now_direction *
                        Motion_Delta_S(vs := rvs,acc := 0,dec := dec,jerk := 0,d_t := t_now); 
                END_IF;
            ELSE
                IF run_mode = 1(*RM_ACC_EQU_DEC*) OR run_mode = 2(*RM_DEC_EQU_DEC*) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_taget_postion := start_postion + now_direction * s_all;
                    ELSIF t_now &lt; t1 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := vs,acc := acc,dec := 0,jerk := 0,d_t := t_now); 
                        ELSE
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := vs,acc := 0,dec := dec,jerk := 0,d_t := t_now);
                        END_IF;
                    ELSIF t_now &lt; t1 + t2 THEN
                        Axis_taget_postion := start_postion + now_direction * ( s1 + 
                            Motion_Delta_S(vs := vmax,acc := 0,dec := 0,jerk := 0,d_t := t_now - t1));
                    ELSIF t_now &lt; t_all THEN
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 +
                            Motion_Delta_S(vs := vmax,acc := 0,dec := dec,jerk := 0,d_t := t_now - t1 - t2));
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) OR run_mode = 4(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSIF t_now &lt;= blend_start_t + t4 THEN
                        Axis_taget_postion := blend_start_pos + now_direction * 
                            Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := 0,jerk := 0,d_t := (t_now - blend_start_t));
                    ELSE
                        IF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                            Axis_taget_postion := blend_start_pos + now_direction * ( s4 +
                                Motion_Delta_S(vs := blend_equal_vel,acc := 0,dec := dec,jerk := 0,d_t := (t_now - blend_start_t - t4)));
                        ELSE
                            Axis_taget_postion := blend_start_pos + now_direction * ( s4 +
                                Motion_Delta_S(vs := blend_equal_vel,acc := acc,dec := 0,jerk := 0,d_t := (t_now - blend_start_t - t4)));
                        END_IF;
                    END_IF;
                END_IF;
            END_IF;
        ELSE                     // S 型模式
            IF direction &lt;&gt; now_direction THEN // 先减速至0
                IF t_now &gt;= rt1 + rt2 +rt3 THEN
                    Axis_taget_postion := start_postion + now_direction * s_rev;
                ELSIF t_now &lt;= rt1 THEN
                    now_stage_vs := rvs;
                    Axis_taget_postion := start_postion + now_direction *
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now);
                ELSIF t_now &lt;= rt1 + rt2 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2;
                    Axis_taget_postion := start_postion + now_direction * ( rs1 +
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - rt1));
                ELSIF t_now &lt; rt1 + rt2 + rt3 THEN
                    now_stage_vs := rvs - jerk * rt1 * rt1 / 2 - jerk * rt1 * rt2;
                    Axis_taget_postion := start_postion + now_direction * ( rs1 + rs2 + 
                        Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * rt1,jerk := jerk,d_t := t_now - rt1 - rt2));
                END_IF;
            ELSE
                IF run_mode = 1(* RM_ACC_EQU_DEC *) OR run_mode = 2(* RM_DEC_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_taget_postion := start_postion + now_direction * s_all;
                    ELSIF t_now &lt;= t1 THEN
                        now_stage_vs := vs;
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := now_stage_vs,acc := as,dec := 0,jerk := jerk,d_t := t_now); 
                        ELSE
                            Axis_taget_postion := start_postion + now_direction * 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := as,jerk := ( -1 * jerk),d_t := t_now);
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 +
                                Motion_Delta_S(vs := now_stage_vs,acc := acc,dec := 0,jerk := 0,d_t := t_now - t1));    // 这里可以填acc是因为到达匀加速阶段时的加速度一定达到预设值
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - t1));
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 THEN
                        IF run_mode = 1(* RM_ACC_EQU_DEC *) THEN
                            now_stage_vs := vs + jerk * t1 * t1 / 2 + jerk * t1 * t2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + 
                                Motion_Delta_S(vs := now_stage_vs,acc := jerk * t1,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2));
                        ELSE
                            now_stage_vs := vs - jerk * t1 * t1 / 2 - jerk * t1 * t2;
                            Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + 
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t1,jerk := jerk,d_t := t_now - t1 - t2));
                        END_IF;
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 THEN
                        now_stage_vs := vmax;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - t1 - t2 - t3));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 THEN
                        now_stage_vs := vmax;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - t1 - t2 - t3 - t4));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 + s5 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := 0,d_t := t_now - t1 - t2 - t3 - t4 - t5));
                    ELSIF t_now &lt;= t1 + t2 + t3 + t4 + t5 + t6 + t7 THEN
                        now_stage_vs := vmax - jerk * t5 * t5 / 2 - jerk * t5 * t6;
                        Axis_taget_postion := start_postion + now_direction * ( s1 + s2 + s3 + s4 + s5 + s6 + 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t5,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - t1 - t2 - t3 - t4 - t5 - t6));
                    END_IF;
                ELSIF run_mode = 3(* RM_BLENDING_EQU_DEC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                        Axis_taget_postion := blend_start_pos + now_direction * 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := blend_start_a,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - blend_start_t);
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - blend_start_t - t5));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := ( -1 * jerk),d_t := t_now - blend_start_t - t5 - t6)); 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := dec,jerk := 0,d_t := t_now - blend_start_t - t5 - t6 - t7));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel - jerk * t7 * t7 / 2 - jerk * t7 * t8;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 + s8 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := jerk * t7,jerk := jerk,d_t := t_now - blend_start_t - t5 - t6 - t7 - t8));
                    END_IF;
                ELSIF run_mode = 4(* RM_BLENDING_EQU_ACC *) THEN
                    IF t_now &gt;= t_all THEN
                        Axis_blending_v := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 132);
                        Axis_taget_postion := MC_RdAxisPar_FL(AxisNum  := Axis_num, AddrOffset := 92);
                        Axis_taget_postion := Axis_taget_postion + direction * Axis_blending_v;
                    ELSIF t_now &lt;= blend_start_t + t5 THEN
                        now_stage_vs := blend_start_v;
                        Axis_taget_postion := blend_start_pos + now_direction * 
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := blend_start_a,jerk := jerk,d_t := UDINT_TO_REAL(t_now) - blend_start_t);
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 THEN
                        now_stage_vs := blend_equal_vel;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 +
                            Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := 0,d_t := t_now - blend_start_t - t5));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 THEN
                        now_stage_vs := blend_equal_vel; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 +
                                Motion_Delta_S(vs := now_stage_vs,acc := 0,dec := 0,jerk := jerk,d_t := t_now - blend_start_t - t5 - t6)); 
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2; 
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 +
                                Motion_Delta_S(vs := now_stage_vs,acc := acc,dec := 0,jerk := 0,d_t := t_now - blend_start_t - t5 - t6 - t7));
                    ELSIF t_now &lt;= blend_start_t + t5 + t6 + t7 + t8 + t9 THEN
                        now_stage_vs := blend_equal_vel + jerk * t7 * t7 / 2 + jerk * t7 * t8;
                        Axis_taget_postion := blend_start_pos + now_direction * ( blend_s1 + s6 + s7 + s8 +
                                Motion_Delta_S(vs := now_stage_vs,acc := jerk * t7,dec := 0,jerk := ( -1 * jerk),d_t := t_now - blend_start_t - t5 - t6 - t7 - t8));
                    END_IF;
                END_IF;
            END_IF;
        END_IF;
        WRAxisPar_Res := MC_WrAxisPar_FL(AxisNum := Axis_num, AddrOffset := 92, Data := Axis_taget_postion);
    END_IF;
END_IF;
END_PROGRAM
